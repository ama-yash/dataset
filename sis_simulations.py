# -*- coding: utf-8 -*-
"""SIS simulations.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u_LJkP82Ow54P5ezrgmNwSVazmyTce4g
"""

import matplotlib.pyplot as plt
import networkx as nx
import random
import pandas as pd

N = 10000
m = 2
G = nx.barabasi_albert_graph(N,m)

"""Gender: Male(0), Female(1) <br>
Ethnicity: South Asian(0), Black(1), White(2), Latin(3)
"""

for n in range(G.number_of_nodes()):
  G.nodes[n]['age'] = random.randint(1,90)
  G.nodes[n]['gender'] = random.randint(0,1)
  G.nodes[n]['ethnicity'] = random.randint(0,3)

asian_count = [x for x,y in G.nodes(data=True) if y['ethnicity']==0]
black_count = [x for x,y in G.nodes(data=True) if y['ethnicity']==1]
white_count = [x for x,y in G.nodes(data=True) if y['ethnicity']==2]
latin_count = [x for x,y in G.nodes(data=True) if y['ethnicity']==3]

print("South Asian Count:", len(asian_count))
print("Black Count:", len(black_count))
print("White Count:", len(white_count))
print("Latin Count:", len(latin_count))

male_count = [x for x,y in G.nodes(data=True) if y['gender']==0]
female_count = [x for x,y in G.nodes(data=True) if y['gender']==1]
print("Male count: ", len(male_count))
print("Female count: ", len(female_count))

seeds = int(N*0.01)

dataframe = pd.read_csv('/content/drive/MyDrive/susceptibility_matrix2.csv')
dataframe

def get_beta(nodeA, nodeB):
    ageA = G.nodes[nodeA]['age']
    ageB = G.nodes[nodeB]['age']
    gender = G.nodes[nodeA]['gender']
    eth = G.nodes[nodeA]['ethnicity']
    if ageA >= 0 and ageA <= 5:
        row = 0
    elif ageA > 5 and ageA <= 10:
        row = 1
    elif ageA > 10 and ageA <= 15:
        row = 2
    elif ageA > 15 and ageA <= 20:
        row = 3
    elif ageA > 20 and ageA <= 25:
        row = 4
    elif ageA > 25 and ageA <= 30:
        row = 5
    elif ageA > 30 and ageA <= 35:
        row = 6
    elif ageA > 35 and ageA <= 40:
        row = 7
    elif ageA > 40 and ageA <= 45:
        row = 8
    elif ageA > 45 and ageA <= 50:
        row = 9
    elif ageA > 50 and ageA <= 55:
        row = 10
    elif ageA > 55 and ageA <= 60:
        row = 11
    elif ageA > 60 and ageA <= 65:
        row = 12
    elif ageA > 65 and ageA <= 70:
        row = 13
    elif ageA > 70 and ageA <= 75:
        row = 14
    elif ageA > 75:
        row = 15

    if ageB >= 0 and ageB <= 5:
        col = 0
    elif ageB > 5 and ageB <= 10:
        col = 1
    elif ageB > 10 and ageB <= 15:
        col = 2
    elif ageB > 15 and ageB <= 20:
        col = 3
    elif ageB > 20 and ageB <= 25:
        col = 4
    elif ageB > 25 and ageB <= 30:
        col = 5
    elif ageB > 30 and ageB <= 35:
        col = 6
    elif ageB > 35 and ageB <= 40:
        col = 7
    elif ageB > 40 and ageB <= 45:
        col = 8
    elif ageB > 45 and ageB <= 50:
        col = 9
    elif ageB > 50 and ageB <= 55:
        col = 10
    elif ageB > 55 and ageB <= 60:
        col = 11
    elif ageB > 60 and ageB <= 65:
        col = 12
    elif ageB > 65 and ageB <= 70:
        col = 13
    elif ageB > 70 and ageB <= 75:
        col = 14
    elif ageB > 75:
        col = 15
    age_p = dataframe.iloc[row,col]
    male_p = 0.17
    female_p = 0.146
    white_p = 0.7392
    sa_p = 0.8799
    black_p = 0.8618
    latin_p = 0.4361
    if eth == 0:
        if gender == 0:
            beta = age_p * male_p * sa_p
        else:
            beta = age_p * female_p * sa_p
    elif eth == 1:
        if gender == 0:
            beta = age_p * male_p * black_p
        else:
            beta = age_p * female_p * black_p
    elif eth == 2:
        if gender == 0:
            beta = age_p * male_p * white_p
        else:
            beta = age_p * female_p * white_p
    elif eth == 3:
        if gender == 0:
            beta = age_p * male_p * latin_p
        else:
            beta = age_p * female_p * latin_p
    return beta

recovery_matrix = pd.read_csv('/content/drive/MyDrive/recovery_matrix.csv',index_col=0)
recovery_matrix

def get_rec(node):
    age = G.nodes[node]['age']
    gender = G.nodes[node]['gender']
    eth = G.nodes[node]['ethnicity']
    #print("AGE: ", age)
    #print("GENDER: ", gender)
    #print("ETHNICITY: ", eth)
    white_p = 0.1585
    sa_p = 0.1428
    black_p = 0.2910
    latin_p = 0.1923
    if gender == 0:
        if age >= 0 and age <= 19:
            rec = 0.073
        elif age > 19 and age <= 29:
            rec = 0.071
        elif age > 29 and age <= 39:
            rec = 0.069
        elif age > 39 and age <= 49:
            rec = 0.067
        elif age > 49 and age <= 59:
            rec = 0.068
        elif age >= 60:
            rec = 0.068
    if gender == 1:
        if age >= 0 and age <= 19:
            rec = 0.075
        elif age > 19 and age <= 29:
            rec = 0.071
        elif age > 29 and age <= 39:
            rec = 0.070
        elif age > 39 and age <= 49:
            rec = 0.067
        elif age > 49 and age <= 59:
            rec = 0.070
        elif age >= 60:
            rec = 0.071
    if eth == 0:
        rec = rec * sa_p
    elif eth == 1:
        rec = rec * black_p
    elif eth == 2:
        rec = rec * white_p
    elif eth == 3:
        rec = rec * latin_p

    return rec

"""PARAMETER SOURCES: <br>
Montoliu, J. and Ruiz de la Cuesta, P., 2020. Modified SEIR model for COVID-19 outbreak in Spain.<br>
Voinsky, I., Baristaite, G. and Gurwitz, D., 2020. Effects of age and sex on recovery from COVID-19: Analysis of 5769 Israeli patients. Journal of Infection, 81(2), pp.e102-e103. <br>
Sarkar, K., Khajanchi, S. and Nieto, J.J., 2020. Modeling and forecasting the COVID-19 pandemic in India. Chaos, Solitons & Fractals, 139, p.110049. <br>
Zhao, Z., Li, X., Liu, F., Zhu, G., Ma, C. and Wang, L., 2020. Prediction of the COVID-19 spread in African countries and implications for prevention and control: A case study in South Africa, Egypt, Algeria, Nigeria, Senegal and Kenya. Science of the Total Environment, 729, p.138959.<br>
Canto, F.J.A. and Avila-Vales, E.J., 2020. Fitting parameters of SEIR and SIRD models of COVID-19 pandemic in Mexico. Preprint, pp.1-11.

"""

nodes = G.number_of_nodes()
def seed_graph(G, seeds):
    rand_nodes = random.sample(range(nodes), seeds)
    for n in range(0, nodes):
        if n in rand_nodes:
            G.nodes[n]['status'] = 'I'
        else:
            G.nodes[n]['status'] = 'S'
def infect():
    for node in range (0, nodes):
        neighbors = list(G.neighbors(node))
        for neighbor in neighbors:
             if random.uniform(0,1) < get_beta(node,neighbor):
                  G.nodes[neighbor]['status'] = 'I'
def recover():
    for node in range (0, nodes):
        neighbors = list(G.neighbors(node))
        for neighbor in neighbors:
             if G.nodes[neighbor]['status'] == 'I':
                  if random.uniform(0,1) < get_rec(neighbor):
                      G.nodes[neighbor]['status'] = 'S'
def count_status():
    infected_count = 0
    susceptible_count = 0
    for node in range(0, nodes):
        if G.nodes[node]['status'] == 'S':
            susceptible_count += 1
        elif G.nodes[node]['status'] == 'I':
            infected_count += 1
        else:
            pass
    return susceptible_count, infected_count

seed_graph(G,seeds)
time = 100
susceptible_population = []
infected_population = []
for t in range(0, time):
    infect()
    recover()
    S, I = count_status()
    susceptible_population.append(S)
    infected_population.append(I)
plt.plot(infected_population, label='infected')
plt.plot(susceptible_population, label='susceptible')
plt.title('SIS Model')
plt.legend()
plt.show()